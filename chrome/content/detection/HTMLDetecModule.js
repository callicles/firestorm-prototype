/* See license.txt for terms of usage */

// This line is to enable debuging massaging and module structure in workers
importScripts(
    "chrome://firestorm/content/detection/detectionModule.js",
    "chrome://firestorm/content/detection/lib/diff_match_patch_uncompressed.js"
);

// ********************************************************************************************* //
// 

var HTMLDetecModule = Obj.extend(DetectionModule,
{
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Module MetaData
    // 
    name: "HTML detector",
    description: "Checks the HTML after the function execution to check for HTML injection",

    HTMLSnipets: [],                                                                           

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Module Methods


    /**
     * Function called in order to detect anomalies in the given dectection data matrix.
     * This matrix is formed as:
     *  [
     *      {
     *         uuid: <id>,
     *          args: <argumentsUsed>,
     *          response: {
     *              HTML: <pageHTML>,
     *              context: <serializedViewOfWindowObject>,
     *              callStack: <SerializedCallStack>,
     *              value: <functionReturnedValue>,
     *              error: <error>                                                                      // is false if there were no error during the 
     *          }                                                                                       // the fuzzing execution, else it contains the error
     *      }                                                                                           //  message
     *  ]
     * @param  {Array} detectionData Matrix of environement data after the function execution
     * @return {Array}               An array of detection results. This should have to following
     *                               shape so that the framework can map correctly the executions to
     *                               the results
     *
     * [
     *     {
     *         uuid: <elementId>                                                                          // same as above
     *         args: <argumentsUsed>
     *         response: {
     *              HTML: <pageHTML>,
     *              context: <serializedViewOfWindowObject>,
     *              callStack: <SerializedCallStack>,
     *              value: <functionReturnedValue>,
     *              error: <error>
     *         },
     *         detection: {                                                                             // generated by the function
     *             result: <boolean>,                                                                   // true if something is wrong, false otherwise
     *             options: <JSONObjectThatwillBePassedToTheTemplateForYourUse>
     *         }
     *     }
     * ]
     */
    detect: function(detectionData){

        var ref = detectionData.find(function(element){
            return element.args == undefined;
        }),
            self = this;

        return detectionData.map(function(element, index, array){
            return {
               "uuid": element.uuid,
               "args": element.args,
               "response": {
                    "HTML": element.response.HTML,
                    "context": element.response.context,
                    "callStack": element.response.callStack,
                    "value": element.response.value,
                    "error": element.response.error
               },
               "detection": {
                   "result": self.detectHTML(ref.response.HTML, element.response.HTML),
                   "index": index
               }
           }
        });
    },

    /**
     * Generates a message info for a function unique execution.
     * 
     * @param  {Object} ElementDetectionInfo Informations on a function execution and detections results:
     *
     *    {
     *         uuid: <elementId>                                                                        // same as above
     *         args: <argumentsUsed>
     *         response: {
     *              HTML: <pageHTML>,
     *              context: <serializedViewOfWindowObject>,
     *              callStack: <SerializedCallStack>,
     *              value: <functionReturnedValue>,
     *              error: <error>,
     *         },
     *         detection: {                                                                             // generated by the function
     *             result: <boolean>,
     *         }
     *     }
     * 
     * @return {String}              String that will be inserted as a text just beneath the test
     *                               results.
     */
    info: function(Element){
        if (Element.detection.result)
            return "There is at list one HTML tag that was injected in the page : "+this.HTMLSnipets[Element.detection.index];
        else
            return "HTML is clean";
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // HTML Module Methods

    detectHTML: function(HTMLref, outputHTML, element){

        if (HTMLref.length >= outputHTML.length){
            this.HTMLSnipets.push([]);
             return false;
        }                                                                                                // If the html length didn't get lengthier then it is 
           
                                                                                                        // that thereÂ couldn't be any HTML injection
        var differencer = new diff_match_patch()

        var diff = differencer.diff_main(HTMLref, outputHTML),
            toReturn = false,
            HTMLtags = [];



        for (var i = 0 ; i < diff.length ; i++){

            if (diff[i][0] === 1 && (/([\<])([^\>]{1,})*([\>])/i).test(diff[i][1])){
                HTMLtags.push(diff[i][1]);
            }
        }
        this.HTMLSnipets.push(HTMLtags);
        if (HTMLtags.length > 0){
            return true;
        } else {
            return false
        }
    }

});

// ********************************************************************************************* //
// Registration

onmessage = function(e){
    HTMLDetecModule.onMessage(e,HTMLDetecModule);
};